# Python 编码错误解决方案

## 问题描述

在 Windows 上运行 Python 脚本时，可能遇到以下错误：

```
UnicodeDecodeError: 'gbk' codec can't decode byte 0xa0 in position 7: illegal multibyte sequence
```

## 原因分析

1. **Windows 默认编码**: Windows 系统默认使用 GBK/CP936 编码
2. **subprocess 输出**: 使用 `subprocess.run()` 时，如果不指定编码，Python 会使用系统默认编码（GBK）
3. **UTF-8 输出**: 很多现代工具（如 WSL、Git）输出 UTF-8 编码的文本
4. **编码冲突**: GBK 无法正确解码 UTF-8 字符，导致错误

## 解决方案

### 方案1: 在 subprocess 中指定编码（推荐）

```python
result = subprocess.run(
    ["command"],
    capture_output=True,
    text=True,
    encoding='utf-8',        # 明确指定 UTF-8 编码
    errors='replace'          # 遇到无法解码的字符时用替换字符代替
)
```

**参数说明**:
- `encoding='utf-8'`: 明确指定使用 UTF-8 编码
- `errors='replace'`: 遇到无法解码的字节时，用 `` 替换而不是抛出异常
- `errors='ignore'`: 遇到无法解码的字节时，直接忽略
- `errors='strict'`: 遇到无法解码的字节时抛出异常（默认）

### 方案2: 使用环境变量设置默认编码

在脚本开头设置：

```python
import os
import sys

# 设置标准输出的编码为 UTF-8
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')
    sys.stderr.reconfigure(encoding='utf-8')
```

### 方案3: 手动解码字节

```python
result = subprocess.run(
    ["command"],
    capture_output=True,
    text=False  # 返回 bytes 而不是 str
)

# 手动解码
stdout = result.stdout.decode('utf-8', errors='replace')
stderr = result.stderr.decode('utf-8', errors='replace')
```

## 文件读取编码问题

### 问题代码
```python
# ❌ 错误：Windows 上默认使用 GBK，可能导致错误
with open("file.txt", "r") as f:
    content = f.read()
```

### 正确做法
```python
# ✅ 正确：明确指定 UTF-8 编码
with open("file.txt", "r", encoding="utf-8") as f:
    content = f.read()

# 或者使用 errors 参数处理编码错误
with open("file.txt", "r", encoding="utf-8", errors='replace') as f:
    content = f.read()
```

## 完整的示例代码

```python
import subprocess
import sys

def safe_run_command(command, encoding='utf-8'):
    """安全地运行命令，处理编码问题"""
    try:
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            encoding=encoding,
            errors='replace',  # 遇到编码错误时替换而不是报错
            check=False  # 不抛出异常，手动检查返回码
        )
        
        if result.returncode != 0:
            print(f"命令执行失败 (返回码: {result.returncode})")
            print(f"错误输出: {result.stderr}")
        
        return result
    except Exception as e:
        print(f"执行命令时出错: {e}")
        return None

# 使用示例
if __name__ == "__main__":
    result = safe_run_command(["wsl", "echo", "测试中文"])
    if result:
        print(f"输出: {result.stdout}")
```

## 最佳实践

1. **始终指定编码**: 在文件操作和 subprocess 中都明确指定 `encoding='utf-8'`
2. **使用 errors 参数**: 使用 `errors='replace'` 或 `errors='ignore'` 处理编码错误
3. **统一使用 UTF-8**: 在整个项目中统一使用 UTF-8 编码
4. **Windows 特殊处理**: 在 Windows 上特别注意编码问题

## 常见错误位置

1. `subprocess.run()` - 没有指定 `encoding`
2. `open()` - 没有指定 `encoding`
3. `print()` 输出包含特殊字符
4. 读取配置文件（JSON、YAML 等）
5. 处理文件名或路径

## 调试技巧

如果仍然遇到编码问题：

```python
import locale
print(f"系统默认编码: {locale.getpreferredencoding()}")
print(f"stdout 编码: {sys.stdout.encoding}")
print(f"stderr 编码: {sys.stderr.encoding}")
```

